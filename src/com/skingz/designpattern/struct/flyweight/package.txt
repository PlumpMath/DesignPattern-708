使用共享对象可有效地支持大量的细粒度的对象。
也就是说在一个系统中如果有多个相同的对象，那么只共享一份就可以了，不必每个都去实例化一个对象。

模式结构
Flyweight:享元接口，通过这个接口Flyweight可以接受并作用于外部状态。痛过这个接口可以传入外部的状态，在享元对象的方法处理中可能会使用这些外部的数据。
ConcreteFlyweight:具体的享元实现对象，必须是共享的，需要封装Flyweight的内部状态。
UnshareConcreteFlyweight:非共享的享元实现对象，并不是所有的Flyweight实现对象都需要共享。非共享的享元实现对象通常是对享元对象的组合对象。
FlyweightFactoty:享元工厂，主要用来创建并管理共享的享元对象，并对外提供访问共享享元的接口。
Client: 享元客户端，主要的工作就是维持一个对Flyweight的引用，计算或存储享元的外部状态，当然这里可访问共享和不共享的Flyweight对象。

模式的优点
减少对象数量，节省内存空间。

模式的缺点
维护共享对象，需要额外开销。（比如：一个线程来回收垃圾）

思考
模式本质：分离和共享

开发中的应用场景：
享元模式由于其共享的特征，可以在任何“池”中操作，比如：线程池，数据库连接池。
String类的设计也是享元模式。